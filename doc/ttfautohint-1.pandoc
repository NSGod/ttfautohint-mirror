% ttfautohint
% Werner Lemberg
%

<!--
  Copyright (C) 2011-2014 by Werner Lemberg.

  This file is part of the ttfautohint library, and may only be used,
  modified, and distributed under the terms given in `COPYING'.  By
  continuing to use, modify, or distribute this file you indicate that you
  have read `COPYING' and understand and accept it fully.

  The file `COPYING' mentioned in the previous paragraph is distributed
  with the ttfautohint library.
-->



Introduction
============

**ttfautohint** is a library written in\ C that takes a TrueType font as
the input, removes its bytecode instructions (if any), and returns a new
font where all glyphs are bytecode hinted using the information given by
FreeType's auto-hinting module.  The idea is to provide the excellent
quality of the auto-hinter on platforms that don't use FreeType.

The library has a single API function, `TTF_autohint`, which is described
[below](#the-ttfautohint-api).

Bundled with the library there are two front-end programs, [`ttfautohint`
and `ttfautohintGUI`](#ttfautohint-and-ttfautohintgui), being a command line
program and an application with a Graphics User Interface (GUI),
respectively.


What exactly are hints?
-----------------------

To cite [Wikipedia](http://en.wikipedia.org/wiki/Font_hinting):

> **Font hinting** (also known as **instructing**) is the use of
> mathematical instructions to adjust the display of an outline font so that
> it lines up with a rasterized grid.  At low screen resolutions, hinting is
> critical for producing a clear, legible text.  It can be accompanied by
> antialiasing and (on liquid crystal displays) subpixel rendering for
> further clarity.

and Apple's [TrueType Reference
Manual](https://developer.apple.com/fonts/TTRefMan/RM03/Chap3.html#features):

> For optimal results, a font instructor should follow these guidelines:
>
>  - At small sizes, chance effects should not be allowed to magnify small
>    differences in the original outline design of a glyph.
>
>  - At large sizes, the subtlety of the original design should emerge.


In general, there are three possible ways to hint a glyph.

 1. The font contains hints (in the original sense of this word) to guide
    the rasterizer, telling it which shapes of the glyphs need special
    consideration.  The hinting logic is partly in the font and partly in
    the rasterizer.  More sophisticated rasterizers are able to produce
    better rendering results.

    This is how Type\ 1 and CFF hints work.

 2. The font contains exact instructions (also called *bytecode*) on how to
    move the points of its outlines, depending on the resolution of the
    output device, and which intentionally distort the (outline) shape to
    produce a well-rasterized result.  The hinting logic is in the font;
    ideally, all rasterizers simply process these instructions to get the
    same result on all platforms.

    This is how TrueType hints work.

 3. The font gets auto-hinted (at run-time).  The hinting logic is
    completely in the rasterizer.  No hints in the font are used or needed;
    instead, the rasterizer scans and analyzes the glyphs to apply
    corrections by itself.

    This is how FreeType's auto-hinter works; see
    [below](#background-and-technical-details) for more.


What problems can arise with TrueType hinting?
----------------------------------------------

While it is relatively easy to specify PostScript hints (either manually or
by an auto-hinter that works at font creation time), creating TrueType
hints is far more difficult.  There are at least two reasons:

  - TrueType instructions form a programming language, operating at a very
    low level.  They are comparable to assembler code, thus lacking all
    high-level concepts to make programming more comfortable.

    Here an example how such code looks like:

    ```
        SVTCA[0]
        PUSHB[ ]  /* 3 values pushed */
        18 1 0
        CALL[ ]
        PUSHB[ ]  /* 2 values pushed */
        15 4
        MIRP[01001]
        PUSHB[ ]  /* 3 values pushed */
        7 3 0
        CALL[ ]
    ```

    Another major obstacle is the fact that font designers usually aren't
    programmers.

  - It is very time consuming to manually hint glyphs.  Given that the
    number of specialists for TrueType hinting is very limited, hinting a
    large set of glyphs for a font or font family can become very expensive.


Why ttfautohint?
----------------

The ttfautohint library brings the excellent quality of FreeType rendering
to platforms that don't use FreeType, yet require hinting for text to look
good -- like Microsoft Windows.  Roughly speaking, it converts the glyph
analysis done by FreeType's auto-hinting module to TrueType bytecode.
Internally, the auto-hinter's algorithm resembles PostScript hinting
methods; it thus combines all three hinting methods discussed
[previously](#what-exactly-are-hints).

The simple interface of the front-ends (both on the command line and with
the GUI) allows quick hinting of a whole font with a few mouse clicks or a
single command on the prompt.  As a result, you get better rendering results
with web browsers, for example.

Across Windows rendering environments today, fonts processed with
ttfautohint look best with ClearType enabled.  This is the default for
Windows\ 7.  Good visual results are also seen in recent MacOS\ X versions
and GNU/Linux systems (including Android, ChromeOS, and other mobile
operating systems) that use FreeType for rendering glyphs.

The goal of the project is to generate a 'first pass' of hinting that font
developers can refine further for ultimate quality.



`ttfautohint` and `ttfautohintGUI`
==================================

On all supported platforms (GNU/Linux, Windows, and Mac OS\ X), the GUI
looks quite similar; the used toolkit is [Qt], which in turn uses the
platform's native widgets.

![`ttfautohintGUI` on GNU/Linux running KDE](img/ttfautohintGUI.png)

Both the GUI and console version share the same features, to be discussed in
the next subsection.

**Warning: ttfautohint cannot always process a font a second time.**
If the font contains composite glyphs, and [option `-c`](#hint-composites)
is used, reprocessing with ttfautohint will fail.  For this reason it is
strongly recommended to *not* delete the original, unhinted font so that you
can always rerun ttfautohint.


Calling `ttfautohint`
---------------------

```
    ttfautohint [OPTION]... [IN-FILE [OUT-FILE]]
```

The TTY binary, `ttfautohint`, works like a Unix filter, this is, it reads
data from standard input if no input file name is given, and it sends its
output to standard output if no output file name is specified.

A typical call looks like the following.

```
    ttfautohint -v -f latn foo.ttf foo-autohinted.ttf
```

For demonstration purposes, here the same using a pipe and redirection.
Note that Windows's default command line interpreter, `cmd.exe`, doesn't
support piping with binary files, unfortunately.

```
    cat foo.ttf | ttfautohint -v -f latn > foo-autohinted.ttf
```


Calling `ttfautohintGUI`
------------------------

```
    ttfautohintGUI [OPTION]...
```

`ttfautohintGUI` doesn't send any output to a console; however, it accepts
the same command line options as `ttfautohint`, setting default values for
the GUI.


Options
-------

Long options can be given with one or two dashes, and with and without an
equal sign between option and argument.  This means that the following forms
are acceptable: `-foo=`*bar*, `--foo=`*bar*, `-foo`\ *bar*, and
`--foo`\ *bar*.

Below, the section title refers to the command's label in the GUI (if
applicable), then comes the name of the corresponding long command line
option and its short equivalent, followed by a description.

Background and technical details on the meaning of the various options are
given [afterwards](#background-and-technical-details).

### Hint Set Range Minimum, Hint Set Range Maximum

See '[Hint Sets](#hint-sets)' for a definition and explanation.

`--hinting-range-min=`*n*, `-l`\ *n*
:   The minimum PPEM value (in pixels) at which hint sets are created.  The
    default value for *n* is\ 8.

`--hinting-range-max=`*n*, `-r`\ *n*
:   The maximum PPEM value (in pixels) at which hint sets are created.  The
    default value for *n* is 50.

Increasing the range given by `-l` and `-r` normally makes the font's
bytecode larger.

### Default Script

`--default-script=`*s*, `-D`\ *s*
:   Set default script to tag *s*, which is a string consisting of four
    lowercase characters like `latn` or `dflt`.  It is needed to specify the
    OpenType default script: After applying all features that are handled
    specially (like small caps or superscript), ttfautohint uses this value
    for the remaining features.  The default value is `latn`.  See
    [below](#opentype-features) for more details.

### Fallback Script

`--fallback-script=`*s*, `-f`\ *s*
:   Set fallback script to tag *s*, which is a string consisting of four
    characters like `latn` or `dflt`.  It gets used for for all glyphs that
    can't be assigned to a script automatically.  See [below](#scripts) for
    more details.

### Hinting Limit

`--hinting-limit=`*n*, `-G`\ *n*
:   The *hinting limit* is the PPEM value (in pixels) where hinting gets
    switched off (using the `INSTCTRL` bytecode instruction, not the `gasp`
    table data); it does not influence the file size.  The default value for
    *n* is 200, which means that the font is not hinted for PPEM values
    larger than 200.

    Note that hinting in the range 'hinting-range-max' up to 'hinting-limit'
    uses the hinting configuration for 'hinting-range-max'.

    To omit a hinting limit, use `--hinting-limit=0` (or check the 'No
    Hinting Limit' box in the GUI).  Since this causes internal math
    overflow in the rasterizer for large pixel values (>\ 1500px approx.) it
    is strongly recommended to not use this except for testing purposes.

### x Height Increase Limit

`--increase-x-height=`*n*, `-x`\ *n*
:   Normally, ttfautohint rounds the x\ height to the pixel grid, with a
    slight preference for rounding up (to use the terminology of TrueType's
    'Super Round' bytecode instruction, the threshold is 5/8px).  If this
    flag is set, values in the range 6\ PPEM to *n*\ PPEM are much more
    often rounded up (setting the threshold to 13/16px).  The default value
    for *n* is 14.  Use this flag to increase the legibility of small sizes
    if necessary; you might get weird rendering results otherwise for glyphs
    like 'a' or 'e', depending on the font design.

    To switch off this feature, use `--increase-x-height=0` (or check the
    'No x\ Height Increase' box in the GUI).  To switch off rounding the
    x\ height to the pixel grid in general, either partially or completely,
    see '[x Height Snapping Exceptions](#x-height-snapping-exceptions)'.

    The following images again use the font 'Mertz Bold'.

    ![At 17px, without option `-x` and '`-w ""`', the hole in glyph 'e'
      looks very grey in the FontForge snapshot, and the GDI ClearType
      rendering (which is the default on older Windows versions) fills it
      completely with black because it uses B/W rendering along the y\ axis.
      FreeType's 'light' autohint mode (which corresponds to ttfautohint's
      'smooth' stem width algorithm) intentionally aligns horizontal lines
      to non-integer (but still discrete) values to avoid large glyph shape
      distortions.](img/e-17px-x14.png)

    ![The same, this time with option `-x 17` (and
      '`-w ""`').](img/e-17px-x17.png)

### x Height Snapping Exceptions

`--x-height-snapping-exceptions=`*string*, `-X`\ *string*
:   A list of comma separated PPEM values or value ranges at which no
    x\ height snapping shall be applied.  A value range has the form
    *value*~1~`-`*value*~2~, meaning *value*~1~\ <= PPEM <=\ *value*~2~.
    *value*~1~ or *value*~2~ (or both) can be missing; a missing value is
    replaced by the beginning or end of the whole interval of valid PPEM
    values, respectively (6\ to 32767).  Whitespace is not significant;
    superfluous commas are ignored, and ranges must be specified in
    increasing order.  For example, the string `"7-9, 11, 13-"` means the
    values 7, 8, 9, 11, 13, 14, 15, etc.  Consequently, if the supplied
    argument is `"-"`, no x\ height snapping takes place at all.  The
    default is the empty string (`""`), meaning no snapping exceptions.

    Normally, x\ height snapping means a slight increase in the overall
    vertical glyph size so that the height of lowercase glyphs gets aligned
    to the pixel grid (this is a global feature, affecting *all* glyphs of a
    font).  However, having larger vertical glyph sizes is not always
    desired, especially if it is not possible to adjust the `usWinAscent`
    and `usWinDescent` values from the font's `OS/2` table so that they are
    not too tight.  See '[Windows Compatibility](#windows-compatibility)'
    for more details.

### Fallback Stem Width

`--fallback-stem-width=`*n*, `-H`\ *n*
:   Set the horizontal stem width (hinting) value for all scripts that lack
    proper standard characters in the font.  The value is given in font
    units and must be a positive integer.  If not set, ttfautohint uses a
    hard-coded default (50\ units at 2048 units per EM, and linearly scaled
    for other UPEM values, for example 24\ units at 1000 UPEM).

    For symbol fonts, you need option `--fallback-script` too (to set up a
    script at all).

    In the GUI, uncheck the 'Default Fallback Stem Width' box to activate
    this feature.

### Windows Compatibility

`--windows-compatibility`, `-W`
:   This option makes ttfautohint add two artificial blue zones, positioned
    at the `usWinAscent` and `usWinDescent` values (from the font's `OS/2`
    table).  The idea is to help ttfautohint so that the hinted glyphs stay
    within this horizontal stripe since Windows clips everything falling
    outside.

    There is a general problem with tight values for `usWinAscent` and
    `usWinDescent`; a good description is given in the [Vertical Metrics
    How-To](http://typophile.com/node/13081).  Additionally, there is a
    special problem with tight values if used in combination with
    ttfautohint because the auto-hinter tends to slightly increase the
    vertical glyph dimensions at smaller sizes to improve legibility.  This
    enlargement can make the heights and depths of glyphs exceed the range
    given by `usWinAscent` and `usWinDescent`.

    If ttfautohint is part of the font creation tool chain, and the font
    designer can adjust those two values, a better solution instead of using
    option `-W` is to reserve some vertical space for 'padding': For the
    auto-hinter, the difference between a top or bottom outline point before
    and after hinting is less than 1px, thus a vertical padding of 2px is
    sufficient.  Assuming a minimum hinting size of 6ppem, adding two pixels
    gives an increase factor of 8÷6 = 1.33.  This is near to the default
    baseline-to-baseline distance used by TeX and other sophisticated text
    processing applications, namely 1.2×designsize, which gives satisfying
    results in most cases.  It is also near to the factor 1.25 recommended
    in the abovementioned how-to.  For example, if the vertical extension of
    the largest glyph is 2000 units (assuming that it approximately
    represents the designsize), the sum of `usWinAscent` and `usWinDescent`
    could be 1.25×2000 = 2500.

    In case ttfautohint is used as an auto-hinting tool for fonts that can
    be no longer modified to change the metrics, option `-W` in combination
    with '`-X "-"`' to suppress any vertical enlargement should prevent
    almost all clipping.

### Adjust Subglyphs

`--adjust-subglyphs`, `-p`
:   *Adjusting subglyphs* makes a font's original bytecode be applied to all
    glyphs before it is replaced with bytecode created by ttfautohint.  This
    makes only sense if your font already has some hints in it that modify
    the shape even at EM size (normally 2048px); in particular, some CJK
    fonts need this because the bytecode is used to scale and shift
    subglyphs (hence the option's long name).  For most fonts, however, this
    is not the case.

### Hint Composites

`--composites`, `-c`
:   By default, the components of a composite glyph get hinted separately.
    If this flag is set, the composite glyph itself gets hinted (and the
    hints of the components are ignored).  Using this flag increases the
    bytecode size a lot, however, it might yield better hinting results.

    If this option is used (and a font actually contains composite glyphs),
    ttfautohint currently cannot reprocess its own output for technical
    reasons, see [below](#the-.ttfautohint-glyph).

### Symbol Font

`--symbol`, `-s`
:   Process a font that ttfautohint would refuse otherwise because it can't
    find a single standard character for any of the supported scripts.

    For all scripts that lack proper standard characters, ttfautohint uses a
    default (hinting) value for the standard stem width instead of deriving
    it from a script's set of standard characters (for the latin script, one
    of them is character 'o').

    Use this option (usually in combination with option `--fallback-script`)
    to hint symbol or dingbat fonts or math glyphs, for example, at the
    expense of possibly poor hinting results at small sizes.

### Dehint

`--dehint`, `-d`
:   Strip off all hints without generating new hints.  Consequently, all
    other hinting options are ignored.  This option is intended for testing
    purposes.

### Add ttfautohint Info

`--no-info`, `-n`
:   Don't add ttfautohint version and command line information to the
    version string or strings (with name ID\ 5) in the font's `name` table.
    In the GUI it is similar: If you uncheck the 'Add ttfautohint info' box,
    information is not added to the `name` table.  Except for testing and
    development purposes it is strongly recommended to not use this option.

### Add TTFA Info Table

`--ttfa-info`, `-t`
:   Add an SFNT table called `TTFA` to the output font that holds a dump of
    all parameters; the data resembles the format of the `--debug` option's
    parameter listing.  In particular, it lists all ttfautohint control
    instructions (which are *not* shown in the `name` table info).  This
    option is mainly for archival purposes so that all information used to
    create a font is stored in the font itself.  Note that such a `TTFA`
    table gets ignored by all TrueType rendering engines.

    Forthcoming versions of the ttfautohint front-ends will be able to use
    this data so that a font can be processed another time with exactly the
    same parameters, thus providing a means for round-tripping fonts.

### Strong Stem Width and Positioning

`--strong-stem-width=`*string*, `-w`\ *string*
:   ttfautohint offers two different routines to handle (horizontal) stem
    widths and stem positions: 'smooth' and 'strong'.  The former uses
    discrete values that slightly increase the stem contrast with almost no
    distortion of the outlines, while the latter snaps both stem widths and
    stem positions to integer pixel values as much as possible, yielding a
    crisper appearance at the cost of much more distortion.

    These two routines are mapped onto three possible rendering targets:

    - grayscale rendering, with or without optimization for subpixel
      positioning (e.g. Android)

    - 'GDI ClearType' rendering: the rasterizer version, as returned by the
      GETINFO bytecode instruction, is in the range 36\ <= version <\ 38 and
      ClearType is enabled (e.g. Windows XP)

    - 'DirectWrite ClearType' rendering: the rasterizer version, as returned
      by the GETINFO bytecode instruction, is >=\ 38, ClearType is enabled,
      and subpixel positioning is enabled also (e.g. Internet Explorer\ 9
      running on Windows\ 7)

    GDI ClearType uses a mode similar to B/W rendering along the vertical
    axis, while DW ClearType applies grayscale rendering.  Additionally,
    only DW ClearType provides subpixel positioning along the x\ axis.  For
    what it's worth, the rasterizers version\ 36 and version\ 38 in
    Microsoft Windows are two completely different rendering engines.

    The command line option expects *string* to contain up to three letters
    with possible values '`g`' for grayscale, '`G`' for GDI ClearType, and
    '`D`' for DW ClearType.  If a letter is found in *string*, the strong
    stem width routine is used for the corresponding rendering target (and
    smooth stem width handling otherwise).  The default value is '`G`', which
    means that strong stem width handling is activated for GDI ClearType
    only.  To use smooth stem width handling for all three rendering
    targets, use the empty string as an argument, usually connoted with
    '`""`'.

    In the GUI, simply set the corresponding check box to select the strong
    width routine for a given rendering target.  If you unset the check box,
    the smooth width routine gets used.

    The following FontForge snapshot images use the font '[Mertz
    Bold](http://code.newtypography.co.uk/mertz-sans/)' (still under
    development) from [Vernon Adams].

    ![The left part shows the glyph 'g' unhinted at 26px, the right part
     with hints, using the 'smooth' stem algorithm.](img/ff-g-26px.png)

    ![The same, but this time using the 'strong'
     algorithm.  Note how the stems are aligned to the pixel
     grid.](img/ff-g-26px-wD.png)

### Control Instructions File
`--control-file=`*file*, `-m`\ *file* (TTY only)
:   Specify the name of a control instructions file to manually tweak the
    hinting process.  This feature can be used to correct glitches in
    ttfautohint's hinting algorithm.

    An entry in a control instructions file has one of the following syntax
    forms:

    > *\[* font-idx *\]*\ \ glyph-id\ \ *`l`|`r`|`n`* points\
    > *\[* font-idx *\]*\ \ glyph-id\ \ *`p`* points\ \ *\[* *`x`* x-shift *\]*\ \ *\[* *`y`* y-shift *\]*\ \ *`@`* ppems

    *font-idx* gives the index of the font in a TrueType Collection.  If
    missing, it is set to zero.  For normal TrueType fonts, only value zero
    is valid.  If starting with `0x` the number is interpreted as
    hexadecimal.  If starting with `0` it gets interpreted as an octal
    value, and as a decimal value otherwise.

    *glyph-id* is a glyph's name as listed in the `post` SFNT table or a
    glyph index.  A glyph name consists of characters from the set
    '`A-Za-z0-9._`' only and does not start with a digit or period, with the
    exceptions of the names '`.notdef`' and '`.null`'.  A glyph index can be
    specified in decimal, octal, or hexadecimal format, the latter two
    indicated by the prefixes `0` and `0x`, respectively.

    The mutually exclusive parameters '`l`', '`r`', or\ '`n`' indicate that
    the following points have left, right, or no direction, respectively,
    overriding ttfautohint's algorithm for setting point directions.  The
    'direction of a point' is the direction of the outline controlled by
    this point.  By changing a point's direction from 'no direction' to
    either left or right, you can create a one-point segment with the given
    direction so that ttfautohint handles the point similar to other
    segments.  Setting a point's direction to 'no direction', ttfautohint no
    longer considers it as part of a segment, thus treating it as a 'weak'
    point.  Changed point directions don't directly modify the outlines;
    they only influence the hinting process.

    Parameter '`p`' makes ttfautohint apply delta exceptions for the given
    points, shifting the points by the given values.  Note that those delta
    exceptions are applied *after* the final `IUP` instructions in the
    bytecode; as a consequence, they are (partially) ignored by rasterizers
    if in ClearType mode.

    Both *points* and *ppems* are number ranges, see '[x Height Snapping
    Exceptions](#x-height-snapping-exceptions)' for the syntax.

    *x-shift* and *y-shift* represent real numbers that get rounded to
    multiples of 1/8 pixels.  The entries for '`x`' and '`y`' are optional;
    if missing, the corresponding value is set to zero.

    Values for *x-shift* and *y-shift* must be in the range [-1.0;1.0]. 
    Values for *ppems* must be in the range [6;53].  Values for *points* are
    limited by the number of points in the glyph.

    Similar to the Bourne shell (`sh` or `bash`), a comment starts with
    character '`#`'; the rest of the line is ignored.  An empty line is
    ignored also.  Both the newline character and '`;`' can be used as a
    separator between exception entries.  A trailing '`\`' at the end of a
    line continues the current line on the next one.

    In case there are multiple shift entries for the same (*font idx*,
    *glyph-id*, *point-idx*, *ppem-value*) quadruplet, the first entry in
    the control instructions file wins.

    Note that only character '`.`' is recognized as a decimal point, and a
    thousands separator is not accepted.

    As an example for delta instructions, let's assume that you want to
    shift points 2, 3, and\ 4 in glyph `Aacute' at ppem sizes 12 and\ 13 by
    a vertical amount of 0.25 pixels.  This corresponds to the line

    ```
        Aacute  p 2-4  y 0.25  @ 12, 13
    ```

    in a control instructions file.

    The following images display glyphs from the font
    [Halant-Regular](http://www.google.com/fonts/specimen/Halant).

    ![The outlines of glyphs 'O' and 'Q', as displayed in
      FontForge.  They are sufficiently similar to expect ttfautohint
      hinting them equal.  However, this is not the
      case.](img/Halant-Regular-O-Q.png)

    ![The same glyphs, shown at 12px before hinting – please ignore the
      outline distortion in the upper right of glyph 'O'; this is a bug in
      FontForge while running the TrueType
      debugger.](img/Halant-Regular-O-Q-unhinted-12px.png)

    ![Using only ttfautohint's '`-w gGD`' parameter to force strong stem
      width and positioning, the hinting of glyph 'Q' is really bad, making
      the glyph vertically two pixels larger!  Reason is that this glyph
      doesn't contain a horizontal segment at the baseline blue zone
      (*y*\ =\ 1; this corresponds to the segment 13-14 in the 'O' glyph).
      Normally, segment 1-2 would form a 'stem' with the baseline segment
      (as segment 7-8 does in glyph 'O').  Instead, it forms a stem with
      segment 19-20, which gets moved down (*y*\ =\ -1) because the whole
      glyph appears to be
      stretched.](img/Halant-Regular-O-good-Q-badly-hinted-12px.png)

### Miscellaneous

Watch input files (GUI only)
:   If this checkbox is set, automatically regenerate the output file as
    soon as an input file (either the font or the control instructions file)
    gets modified.

    Pressing the 'Run' button starts watching.  If an error occurs, watching
    stops and must be restarted with the 'Run' button.

`--ignore-restrictions`, `-i`
:   By default, fonts that have bit\ 1 set in the 'fsType' field of the
    `OS/2` table are rejected.  If you have a permission of the font's legal
    owner to modify the font, specify this command line option.

    If this option is not set, `ttfautohintGUI` shows a dialogue to handle
    such fonts if necessary.

`--help`, `-h`
:   On the console, print a brief documentation on standard output and exit.
    This doesn't work with `ttfautohintGUI` on MS Windows.

`--version`, `-v`
:   On the console, print version information on standard output and exit.
    This doesn't work with `ttfautohintGUI` on MS Windows.

`--debug`
:   Print *a lot* of debugging information on standard error while
    processing a font (you should redirect stderr to a file).  This
    doesn't work with `ttfautohintGUI` on MS Windows.



Background and Technical Details
================================

[Real-Time Grid Fitting of Typographic
Outlines](http://www.tug.org/TUGboat/tb24-3/lemberg.pdf) is a scholarly
paper that describes FreeType's auto-hinter in some detail.  Regarding the
described data structures it is slightly out of date, but the algorithm
itself hasn't changed in general.

The next few subsections are mainly based on this article, introducing some
important concepts.  Note that ttfautohint only does hinting along the
vertical direction (modifying y\ coordinates only).


Segments and Edges
------------------

A glyph consists of one or more *contours* (this is, closed curves).  For
example, glyph 'O' consists of two contours, while glyph 'I' has only one.

![The letter 'O' has two contours, an inner and an outer one, while letter
  'I' has only an outer contour.](img/o-and-i)

A *segment* is a series of consecutive points of a contour (including its
Bézier control points) that are approximately aligned along a coordinate
axis.

![A serif.  Contour and control points are represented by squares and
  circles, respectively.  The bottom 'line' DE is approximately aligned
  along the horizontal axis, thus it forms a segment of 7\ points.  Together
  with the two other horizontal segments, BC and FG, they form two edges
  (BC+FG, DE).](img/segment-edge)

An *edge* corresponds to a single coordinate value on the main dimension
that collects one or more segments (allowing for a small threshold).  While
finding segments is done on the unscaled outline, finding edges is bound to
the device resolution.  See [below](#hint-sets) for an example.

The analysis to find segments and edges is specific to a writing
system, see [below](#writing-systems).


Feature Analysis
----------------

The auto-hinter analyzes a font in two steps.  Right now, everything
described here happens for the horizontal axis only, providing vertical
hinting.

  * Global Analysis

    This affects the hinting of all glyphs, trying to give them a uniform
    appearance.

      + Compute standard horizontal stem width of the font.  The value
        is normally taken from glyphs that resemble letter 'o'.

      + Compute blue zones, see [below](#blue-zones).

    If the stem widths of single glyphs differ by a large value, or if
    ttfautohint fails to find proper blue zones, hinting becomes quite poor,
    possibly leading even to severe shape distortions.


Table: script-specific standard characters of the 'latin' writing system

    Script    Standard characters
  ----------  ---------------------
  `cyrl`      'о', U+043E, CYRILLIC SMALL LETTER O
              'О', U+041E, CYRILLIC CAPITAL LETTER O
  `grek`      'ο', U+03BF, GREEK SMALL LETTER OMICRON
              'Ο', U+039F, GREEK CAPITAL LETTER OMICRON
  `hebr`      'ם', U+05DD, HEBREW LETTER FINAL MEM
  `latn`      'o', U+006F, LATIN SMALL LETTER O
              'O', U+004F, LATIN CAPITAL LETTER O
              '0', U+0030, DIGIT ZERO


  * Glyph Analysis

    This is a per-glyph operation.

      + Find segments and edges.

      + Link edges together to find stems and serifs.  The abovementioned
        paper gives more details on what exactly constitutes a stem or a
        serif and how the algorithm works.


Blue Zones
----------

![Two blue zones relevant to the glyph 'a'.  Vertical point coordinates of
  *all* glyphs within these zones are aligned, provided the blue zone is
  active (this is, its vertical size is smaller than
  3/4\ pixels).](img/blue-zones)

Outlines of certain characters are used to determine *blue zones*.  This
concept is the same as with Type\ 1 fonts: All glyph points that lie in
certain small horizontal zones get aligned vertically.

Here a series of tables that show the blue zone characters of the latin
writing system's available scripts; the values are hard-coded in the source
code.  Since the auto-hinter takes mean values it is not necessary that all
characters of a zone are present.


Table: `latn` blue zones

  ID    Blue zone                              Characters
  ----  -----------                            ------------
  1     top of capital letters                 THEZOCQS
  2     bottom of capital letters              HEZLOCUS
  3     top of 'small f' like letters          fijkdbh
  4     top of small letters                   xzroesc
  5     bottom of small letters                xzroesc
  6     bottom of descenders of small letters  pqgjy


The 'round' characters (e.g. 'OCQS') from Zones 1, 2, and 5 are also used to
control the overshoot handling; to improve rendering at small sizes, zone\ 4
gets adjusted to be on the pixel grid; cf. the [`--increase-x-height`
option](#x-height-increase-limit).


Table: `grek` blue zones

  ID    Blue zone                              Characters
  ----  -----------                            ------------
  1     top of capital letters                 ΓΒΕΖΘΟΩ
  2     bottom of capital letters              ΒΔΖΞΘΟ
  3     top of 'small beta' like letters       βθδζλξ
  4     top of small letters                   αειοπστω
  5     bottom of small letters                αειοπστω
  6     bottom of descenders of small letters  βγημρφχψ


Table: `cyrl` blue zones

  ID    Blue zone                              Characters
  ----  -----------                            ------------
  1     top of capital letters                 БВЕПЗОСЭ
  2     bottom of capital letters              БВЕШЗОСЭ
  3     top of small letters                   хпншезос
  4     bottom of small letters                хпншезос
  5     bottom of descenders of small letters  руф


Table: `hebr` blue zones

  ID    Blue zone                              Characters
  ----  -----------                            ------------
  1     top of letters                         בדהחךכםס
  2     bottom of letters                      בטכםסצ
  3     bottom of descenders of letters        קךןףץ


![This image shows the relevant glyph terms for vertical blue zone
  positions.](img/glyph-terms)


Grid Fitting
------------

Aligning outlines along the grid lines is called *grid fitting*.  It doesn't
necessarily mean that the outlines are positioned *exactly* on the grid,
however, especially if you want a smooth appearance at different sizes.
This is the central routine of the auto-hinter; its actions are highly
dependent on the used writing system.  Currently, only one writing system is
available (latin), providing support for scripts like Latin or Greek.

  * Align edges linked to blue zones.

  * Fit edges to the pixel grid.

  * Align serif edges.

  * Handle remaining 'strong' points.  Such points are not part of an edge
    but are still important for defining the shape.  This roughly
    corresponds to the `IP` TrueType instruction.

  * Everything else (the 'weak' points) is handled with an `IUP`
    instruction.

The following images illustrate the hinting process, using glyph 'a' from
the freely available font '[Ubuntu Book](http://font.ubuntu.com)'.  The
manual hints were added by [Dalton Maag Ltd], the used application to create
the hinting debug snapshots was [FontForge].

![Before hinting.](img/a-before-hinting.png)

![After hinting, using manual hints.](img/a-after-hinting.png)

![After hinting, using ttfautohint.  Note that the hinting process
  doesn't change horizontal positions.](img/a-after-autohinting.png)


Hint Sets
---------

In ttfautohint terminology, a *hint set* is the *optimal* configuration for
a given PPEM (pixel per EM) value.

In the range given by the `--hinting-range-min` and `--hinting-range-max`
options, ttfautohint creates hint sets for every PPEM value.  For each
glyph, ttfautohint automatically determines whether a new set should be
emitted for a PPEM value if it finds that it differs from a previous one.
For some glyphs it is possible that one set covers, say, the range
8px-1000px, while other glyphs need 10 or more such sets.

In the PPEM range below `--hinting-range-min`, ttfautohint always uses just
one set, in the PPEM range between `--hinting-range-max` and
`--hinting-limit`, it also uses just one set.

One of the hinting configuration parameters is the decision which segments
form an edge.  For example, let us assume that two segments get aligned on a
single horizontal edge at 11px, while two edges are used at 12px.  This
change makes ttfautohint emit a new hint set to accomodate this situation.
The next images illustrate this, using a Cyrillic letter (glyph 'afii10108')
from the 'Ubuntu book' font, processed with ttfautohint.

![Before hinting, size 11px.](img/afii10108-11px-before-hinting.png)

![After hinting, size 11px.  Segments 43-27-28 and 14-15 are aligned on a
  single edge, as are segments 26-0-1 and
  20-21.](img/afii10108-11px-after-hinting.png)

![Before hinting, size 12px.](img/afii10108-12px-before-hinting.png)

![After hinting, size 12px.  The segments are not aligned.  While
  segments 43-27-28 and 20-21 now have almost the same horizontal position,
  they don't form an edge because the outlines passing through the segments
  point into different directions.](img/afii10108-12px-after-hinting.png)

Obviously, the more hint sets get emitted, the larger the bytecode
ttfautohint adds to the output font.  To find a good value\ *n* for
`--hinting-range-max`, some experimentation is necessary since *n* depends
on the glyph shapes in the input font.  If the value is too low, the hint
set created for the PPEM value\ *n* (this hint set gets used for all larger
PPEM values) might distort the outlines too much in the PPEM range given
by\ *n* and the value set by `--hinting-limit` (at which hinting gets
switched off).  If the value is too high, the font size increases due to
more hint sets without any noticeable hinting effects.

Similar arguments hold for `--hinting-range-min` except that there is no
lower limit at which hinting is switched off.

An example.  Let's assume that we have a hinting range 10\ <= ppem <=\ 100,
and the hinting limit is set to 250.  For a given glyph, ttfautohint finds
out that four hint sets must be computed to exactly cover this hinting
range: 10-15, 16-40, 41-80, and 81-100.  For ppem values below 10ppem, the
hint set covering 10-15ppem is used, for ppem values larger than 100 the
hint set covering 81-100ppem is used.  For ppem values larger than 250, no
hinting gets applied.


Composite Glyphs
----------------

The ttfautohint library (and programs) supports two solutions for handling
composite glyphs, to be controlled with [option
`--composites`](#hint-composites).  This section contains some general
information, then covers the case where the option if off, while the next
section describes how ttfautohint behaves if this option is activated.

Regardless of the `--composites` option, ttfautohint performs a scan over
all composite glyphs to assure that components of a composite glyph inherit
its style, as described [later](#opentype-features).  However, components
that are shifted vertically will be skipped.  For example, if the glyph
'Agrave' uses a shifted 'grave' accent glyph, the accent is ignored.  On the
other hand, if there is a glyph 'agrave' that uses the same 'grave' glyph
vertically unshifted, 'grave' does inherit the style.

If `--composites` is off, components are hinted separately, then put
together.  Separate hinting implies that the current style's blue zones are
applied to all subglyphs in its original, unshifted positions.


The '\.ttfautohint' Glyph
-------------------------

If [option `--composites`](#hint-composites) is used, ttfautohint doesn't
hint subglyphs of composite glyphs separately.  Instead, it hints the whole
glyph, this is, composites get recursively expanded internally so that they
form simple glyphs, then hints are applied -- this is the normal working
mode of FreeType's auto-hinter.

One problem, however, must be solved: Hinting for subglyphs (which usually
are used as normal glyphs also) must be deactivated so that nothing but the
final bytecode of the composite gets executed.

The trick used by ttfautohint is to prepend a composite element called
'\.ttfautohint', a dummy glyph with a single point, and which has a single
job: Its bytecode increases a variable (to be more precise, it is a CVT
register called `cvtl_is_subglyph` in the source code), indicating that we
are within a composite glyph.  The final bytecode of the composite glyph
eventually decrements this variable again.

As an example, let's consider composite glyph 'Agrave' ('À'), which has the
subglyph 'A' as the base and 'grave' as its accent.  After processing with
ttfautohint it consists of three components: '\.ttfautohint', 'A', and
'grave' (in this order).

  Bytecode of    Action
  -------------  --------
  .ttfautohint   increase `cvtl_is_subglyph` (now: 1)
  A              do nothing because `cvtl_is_subglyph` > 0
  grave          do nothing because `cvtl_is_subglyph` > 0
  Agrave         decrease `cvtl_is_subglyph` (now: 0)\
                 apply hints because `cvtl_is_subglyph` == 0

Some technical details (which you might skip): All glyph point indices get
adjusted since each '\.ttfautohint' subglyph shifts all following indices by
one.  This must be done for both the bytecode and one subformat of
OpenType's `GPOS` anchor tables.

While this approach works fine on all tested platforms, there is one single
drawback: Direct rendering of the '\.ttfautohint' subglyph (this is,
rendering as a stand-alone glyph) disables proper hinting of all glyphs in
the font!  Under normal circumstances this never happens because
'\.ttfautohint' doesn't have an entry in the font's `cmap` table.  (However,
some test and demo programs like FreeType's `ftview` application or other
glyph viewers that are able to bypass the `cmap` table might be affected.)


Writing Systems
---------------

In FreeType terminology, a writing system is a set of functions that
provides auto-hinting for certain scripts.  Right now, only two writing
systems from FreeType's auto-hinter are available in ttfautohint: 'dummy'
and 'latin'.  The former handles the 'no-script' case; details to 'latin'
follow in the next section.


Scripts
-------

ttfautohint needs to know which script should be used to hint a specific
glyph.  To do so, it checks a glyph's Unicode character code whether it
belongs to a given script.

Here is the hardcoded list of character ranges that are used for scripts in
the 'latin' writing system.  As you can see, this also covers some non-latin
scripts (in the Unicode sense) that have similar typographical properties.

In ttfautohint, scripts are identified by four-character tags.  The value
`none` indicates 'no script'.


Table: `latn` character ranges

     Character range     Description
  ---------------------  -------------
  `0x0020` - `0x007F`    Basic Latin (no control characters)
  `0x00A0` - `0x00FF`    Latin-1 Supplement (no control characters)
  `0x0100` - `0x017F`    Latin Extended-A
  `0x0180` - `0x024F`    Latin Extended-B
  `0x0250` - `0x02AF`    IPA Extensions
  `0x02B0` - `0x02FF`    Spacing Modifier Letters
  `0x0300` - `0x036F`    Combining Diacritical Marks
  `0x1D00` - `0x1D7F`    Phonetic Extensions
  `0x1D80` - `0x1DBF`    Phonetic Extensions Supplement
  `0x1DC0` - `0x1DFF`    Combining Diacritical Marks Supplement
  `0x1E00` - `0x1EFF`    Latin Extended Additional
  `0x2000` - `0x206F`    General Punctuation
  `0x2070` - `0x209F`    Superscripts and Subscripts
  `0x20A0` - `0x20CF`    Currency Symbols
  `0x2150` - `0x218F`    Number Forms
  `0x2460` - `0x24FF`    Enclosed Alphanumerics
  `0x2C60` - `0x2C7F`    Latin Extended-C
  `0x2E00` - `0x2E7F`    Supplemental Punctuation
  `0xA720` - `0xA7FF`    Latin Extended-D
  `0xFB00` - `0xFB06`    Alphabetical Presentation Forms (Latin Ligatures)
  `0x1D400` - `0x1D7FF`  Mathematical Alphanumeric Symbols
  `0x1F100` - `0x1F1FF`  Enclosed Alphanumeric Supplement


Table: `grek` character ranges

     Character range     Description
  ---------------------  -------------
  `0x0370` - `0x03FF`    Greek and Coptic
  `0x1F00` - `0x1FFF`    Greek Extended


Table: `cyrl` character ranges

     Character range     Description
  ---------------------  -------------
  `0x0400` - `0x04FF`    Cyrillic
  `0x0500` - `0x052F`    Cyrillic Supplement
  `0x2DE0` - `0x2DFF`    Cyrillic Extended-A
  `0xA640` - `0xA69F`    Cyrillic Extended-B


Table: `hebr` character ranges

     Character range     Description
  ---------------------  -------------
  `0x0590` - `0x05FF`    Hebrew
  `0xFB1D` - `0xFB4F`    Alphabetic Presentation Forms (Hebrew)


If a glyph's character code is not covered by a script range, it is not
hinted (or rather, it gets hinted by the 'dummy' auto-hinting module that
essentially does nothing).  This can be changed by specifying a *fallback
script*; see [option `--fallback-script`](#fallback-script).


OpenType Features
-----------------

(Please read the [OpenType specification] for details on *features*, `GSUB`,
and `GPOS` tables, and how they relate to scripts.)

For modern OpenType fonts, character ranges are not sufficient to handle
scripts.

  * Due to glyph substitution in the font (as specified in a font's `GSUB`
    table), which handles ligatures and similar typographic features, there
    is no longer a one-to-one mapping from an input Unicode character to a
    glyph index.  Some ligatures, like 'fi', actually do have Unicode values
    for historical reasons, but most of them don't.  While it is possible to
    map ligature glyphs into Unicode's Private Use Area (PUA), code values
    from this area are arbitrary by definition and thus unusable for
    ttfautohint.

  * Some features like `sups` (for handling superscript) completely change
    the appearance and even vertical position of the affected glyphs.
    Obviously, the blue zones for 'normal' glyphs no longer fit, thus the
    auto-hinter puts them into a separate group (called *style* in FreeType
    speak), having its own set of blue zones.


Table: OpenType features handled specially by ttfautohint

    Feature tag    Description
  ---------------  -------------
  `c2cp`           petite capitals from capitals
  `c2sc`           small capitals from capitals
  `ordn`           ordinals
  `pcap`           petite capitals
  `sinf`           scientific inferiors
  `smcp`           small capitals
  `subs`           subscript
  `sups`           superscript
  `titl`           titling


There are two conditions to get a valid style for a feature in a given
script.

 1. One of the script's standard characters must be available in the
    feature.

 2. The feature must provide characters to form at least one blue zone; see
    [above](#blue-zones).

An additional complication is that features from the above table might use
data not only from the `GSUB` but also from the `GPOS` table, containing
information for glyph positioning.  For example, the `sups` feature for
superscripts might use the same glyphs as the `subs` feature for subscripts,
simply moved up.  ttfautohint skips such vertically shifted glyphs (except
for accessing standard characters) because glyph positioning happens after
hinting.  Continuing our example, the `sups` feature wouldn't form a style,
contrary to `subs`, which holds the unshifted glyphs.

The remaining OpenType features of a script are not handled specially; the
affected glyphs are simply hinted together with the 'normal' glyphs of the
script.

Note that a font might still contain some features not covered yet: OpenType
has the concept of a *default script*; its data gets used for all scripts
that aren't explicitly handled in a font.  By default, ttfautohint unifies
all affected glyphs from default script features with the `latn` script.
This can be changed with [option `--default-script`](#default-script), if
necessary.


ttfautohint uses the [HarfBuzz] library for handling OpenType features.


SFNT Tables
-----------

ttfautohint touches almost all SFNT tables within a TrueType or OpenType
font.  Note that only OpenType fonts with TrueType outlines are supported.
OpenType fonts with a `CFF` table (this is, with PostScript outlines) won't
work.

  * `glyf`: All hints in the table are replaced with new ones.  If option
    [`--composites`](#hint-composites) is used, one glyph gets added (namely
    the '\.ttfautohint' glyph) and all composites get an additional
    component.

  * `cvt`, `prep`, and `fpgm`: These tables get replaced with data
    necessary for the new hinting bytecode.

  * `gasp`: Set up to always use grayscale rendering, for all sizes, with
    grid-fitting for standard hinting, and symmetric grid-fitting and
    symmetric smoothing for horizontal subpixel hinting (ClearType).

  * `DSIG`: If it exists, it gets replaced with a dummy version.
    ttfautohint can't digitally sign a font; you have to do that afterwards.

  * `name`: The 'version' entries are modified to add information about the
    parameters that have been used for calling ttfautohint.  This can be
    controlled with the [`--no-info`](#add-ttfautohint-info) option.

  * `GPOS`, `hmtx`, `loca`, `head`, `maxp`, `post`: Updated to fit the
    additional '\.ttfautohint' glyph, the additional subglyphs in
    composites, and the new hinting bytecode.

  * `LTSH`, `hdmx`: Since ttfautohint doesn't do any horizontal hinting,
    those tables are superfluous and thus removed.

  * `VDMX`: Removed, since it depends on the original bytecode, which
    ttfautohint removes.  A font editor might recompute the necessary data
    later on.


Problems
--------

### Interaction With FreeType

Recent versions of FreeType have an experimental extension for handling
subpixel hinting; it is off by default and can be activated by defining the
macro `TT_CONFIG_OPTION_SUBPIXEL_HINTING` at compile time.  This code has
been contributed mainly by [Infinality], being a subset of his original
patch.  Many GNU/Linux distributions activate this code, or provide packages
to activate it.

This extension changes the behaviour of many bytecode instructions to get
better rendering results.  However, not all changes are global; some of them
are specific to certain fonts.  For example, it contains font-specific
improvements for the '[DejaVu] Sans' font family.  The list of affected
fonts is hard-coded; it can be found in FreeType's source code file
`ttsubpix.c`.

If you are going to process such specially-handled fonts with ttfautohint,
serious rendering problems might show up.  Since ttfautohint (intentionally)
doesn't change the font name in the `name` table, the Infinality extension
has no chance to recognize that the hints are different.  All such problems
vanish if the font gets renamed in its `name` table (the name of the font
file itself doesn't matter).

### Incorrect Unicode Character Map

Fonts with an incorrect Unicode `cmap` table will not be properly hinted by
ttfautohint.  Especially older fonts do cheat; for example, there exist
Hebrew fonts that map its glyphs to character codes 'A', 'B', etc., to make
them work with non-localized versions of Windows\ 98, say.

Since ttfautohint needs to find both standard and blue zone characters, it
relies on correct Unicode values.  If you want to handle such fonts, please
fix their `cmap` tables accordingly.

### Irregular Glyph Heights

The central concept of ttfautohint's hinting algorithm, as discussed
[above](#segments-and-edges), is to identify horizontal segments at extremum
positions, especially for blue zones.  If such a segment is missing, it
cannot be associated with a blue zone, possibly leading to irregular heights
for the particular glyph.

If a font designer is able to adjust the outlines, such problems can be
remedied by adding tiny horizontal segments at the problematic extremum
positions.  Such segments should have a horizontal length of at least
20\ font units (assuming 2048 units per EM)^[To be more precise, the sum of
the height and width of a segment must be at least 20 font units, and the
height multiplied by\ 14 must not exceed the length.  Thus (19,1) is also a
valid minimum (length,height) pair, while (18,2) isn't.  The value\ 20 is
heuristic and hard-coded, as is the value\ 14 (corresponding to a slope of
approx. 4.1°).].

### Diagonals

ttfautohint doesn't handle diagonal lines specially.  For thin outlines,
this might lead to strokes that look too thick at smaller sizes.  A font
designer might compensate this to a certain amount by slightly reducing the
stroke width of diagonal lines.  However, in many cases the sub-optimal
appearance of a stroke with borders that don't exactly fit the pixel grid is
not the outline itself but an incorrect gamma value of the monitor: People
tend to not properly adjust it, and the default values of most operating
systems are too low, causing too much darkening of such strokes.  It is thus
of vital importance to compare ttfautohint's results with similar fonts to
exclude any systematic effect not related to the outlines themselves.
